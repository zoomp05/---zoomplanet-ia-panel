/**
 * ModuleInitializer
 * 
 * Sistema de inicializaci√≥n de m√≥dulos que:
 * - Carga m√≥dulos en el orden correcto usando ModuleDependencyResolver
 * - Gestiona el ciclo de vida de los m√≥dulos (init, mount, unmount, destroy)
 * - Registra y ejecuta hooks en cada fase del ciclo de vida
 * - Gestiona lazy loading de m√≥dulos no cr√≠ticos
 * - Provee contexto compartido entre m√≥dulos
 * - Maneja errores de inicializaci√≥n con fallbacks
 */

import ModuleDependencyResolver from './ModuleDependencyResolver.js';
import SessionManager from '../session/SessionManager.js';
import configManager from '../config/ConfigManager.js';
import { loadModuleConfig } from '../config/configLoader.js';

/**
 * Estados del ciclo de vida de un m√≥dulo
 */
export const ModuleLifecycleState = {
  UNINITIALIZED: 'uninitialized',    // M√≥dulo no inicializado
  INITIALIZING: 'initializing',      // En proceso de inicializaci√≥n
  INITIALIZED: 'initialized',        // Inicializado pero no montado
  MOUNTING: 'mounting',              // En proceso de montaje
  MOUNTED: 'mounted',                // Montado y activo
  UNMOUNTING: 'unmounting',          // En proceso de desmontaje
  UNMOUNTED: 'unmounted',            // Desmontado pero puede volver a montarse
  DESTROYING: 'destroying',          // En proceso de destrucci√≥n
  DESTROYED: 'destroyed',            // Destruido completamente
  ERROR: 'error'                     // Error en alguna fase
};

/**
 * Clase que gestiona la inicializaci√≥n y ciclo de vida de m√≥dulos
 */
export class ModuleInitializer {
  constructor(siteConfig) {
    this.siteConfig = siteConfig;
    this.siteId = siteConfig.siteId;
    
    console.log('üîç DEBUG - ModuleInitializer constructor:', {
      siteId: siteConfig.siteId,
      hasModules: !!siteConfig.modules,
      modulesType: typeof siteConfig.modules,
      modulesLength: siteConfig.modules?.length,
      modulesSample: siteConfig.modules?.slice(0, 2)
    });
    
    // Servicios core
    this.dependencyResolver = new ModuleDependencyResolver(siteConfig);
    this.sessionManager = new SessionManager(siteConfig);
    this.configManager = configManager;
    
    // Estado de m√≥dulos
    this.modules = new Map(); // instanceId -> { config, instance, state, error }
    this.hooks = new Map();   // instanceId -> { hookName -> [callbacks] }
    this.contexts = new Map(); // instanceId -> shared context
    
    // Orden de carga
    this.loadOrder = [];
    this.lazyModules = [];
    
    // Estado de inicializaci√≥n
    this.initialized = false;
    this.initializing = false;
    
    // Listeners de eventos
    this.listeners = new Map();
    
    // Cache de m√≥dulos cargados din√°micamente
    this.moduleCache = new Map();
  }

  /**
   * Inicializa todos los m√≥dulos cr√≠ticos del site
   */
  async initialize() {
    if (this.initialized || this.initializing) {
      console.warn(`[ModuleInitializer] Site ${this.siteId} ya est√° inicializado o inicializando`);
      return;
    }

    this.initializing = true;
    this.emit('initialization:start', { siteId: this.siteId });

    try {
      // 1. Cargar configuraciones din√°micas desde DB
      console.log(`[ModuleInitializer] Cargando configuraci√≥n del site ${this.siteId}...`);
      const dynamicSiteConfig = await this.configManager.loadSiteConfig(this.siteId);
      
      // Actualizar siteConfig con overrides de DB (preservando modules array)
      const originalModules = this.siteConfig.modules;
      this.siteConfig = { ...this.siteConfig, ...dynamicSiteConfig };
      // Si dynamicSiteConfig no tiene modules, restaurar el original
      if (!dynamicSiteConfig.modules) {
        this.siteConfig.modules = originalModules;
      }
      
      console.log('üîç DEBUG - After DB merge:', {
        hasModules: !!this.siteConfig.modules,
        modulesLength: this.siteConfig.modules?.length
      });
      
      // Actualizar el dependencyResolver con el siteConfig actualizado
      this.dependencyResolver = new ModuleDependencyResolver(this.siteConfig);

      // 2. Resolver orden de carga de m√≥dulos
      console.log(`[ModuleInitializer] Resolviendo dependencias de m√≥dulos...`);
      this.loadOrder = this.dependencyResolver.resolveLoadOrder();
      
      // 3. Separar m√≥dulos cr√≠ticos de lazy
      const { critical, lazy } = this.separateCriticalAndLazy();
      this.lazyModules = lazy;

      console.log(`[ModuleInitializer] M√≥dulos cr√≠ticos: ${critical.length}, Lazy: ${lazy.length}`);

      // 4. Inicializar m√≥dulos cr√≠ticos
      await this.initializeModules(critical);

      // 5. Montar m√≥dulos cr√≠ticos
      await this.mountModules(critical);

      // 6. Configurar lazy loading para m√≥dulos no cr√≠ticos
      this.setupLazyLoading(lazy);

      this.initialized = true;
      this.initializing = false;
      
      this.emit('initialization:complete', { 
        siteId: this.siteId, 
        criticalCount: critical.length,
        lazyCount: lazy.length
      });

      console.log(`[ModuleInitializer] Site ${this.siteId} inicializado correctamente`);

    } catch (error) {
      this.initializing = false;
      this.emit('initialization:error', { siteId: this.siteId, error });
      console.error(`[ModuleInitializer] Error inicializando site ${this.siteId}:`, error);
      throw error;
    }
  }

  /**
   * Separa m√≥dulos cr√≠ticos de lazy seg√∫n configuraci√≥n
   */
  separateCriticalAndLazy() {
    const critical = [];
    const lazy = [];

    for (const instanceId of this.loadOrder) {
      const moduleConfig = this.siteConfig.modules.find(m => m.instanceId === instanceId);
      if (!moduleConfig) continue;

      if (moduleConfig.lazy) {
        lazy.push(instanceId);
      } else {
        critical.push(instanceId);
      }
    }

    return { critical, lazy };
  }

  /**
   * Inicializa una lista de m√≥dulos
   */
  async initializeModules(moduleIds) {
    for (const instanceId of moduleIds) {
      try {
        await this.initializeModule(instanceId);
      } catch (error) {
        console.error(`[ModuleInitializer] Error inicializando ${instanceId}:`, error);
        
        // Marcar m√≥dulo con error pero continuar con los dem√°s
        this.modules.set(instanceId, {
          config: this.getModuleConfig(instanceId),
          instance: null,
          state: ModuleLifecycleState.ERROR,
          error
        });
      }
    }
  }

  /**
   * Inicializa un m√≥dulo individual
   */
  async initializeModule(instanceId) {
    const moduleConfig = this.getModuleConfig(instanceId);
    if (!moduleConfig) {
      throw new Error(`Configuraci√≥n no encontrada para m√≥dulo ${instanceId}`);
    }

    console.log(`[ModuleInitializer] Inicializando m√≥dulo ${instanceId}...`);

    // Cambiar estado
    this.setModuleState(instanceId, ModuleLifecycleState.INITIALIZING);
    this.emit('module:initializing', { instanceId, config: moduleConfig });

    try {
      // 1. Determinar el nombre del m√≥dulo y su jerarqu√≠a
      const moduleName = moduleConfig.module || moduleConfig.name || instanceId;
      const parentModule = this.getParentModule(instanceId);
      
      console.log(`[ModuleInitializer] Cargando config en cascada para ${moduleName}`, {
        parent: parentModule,
        site: this.siteId
      });

      // 2. Cargar configuraci√≥n usando ConfigLoader (cascada de 3 niveles)
      let cascadeConfig = null;
      try {
        cascadeConfig = await loadModuleConfig(moduleName, parentModule, this.siteId, {
          silent: true, // No fallar si no hay configs opcionales
          throwOnMissing: false
        });
      } catch (error) {
        console.warn(`[ModuleInitializer] Config en cascada no disponible para ${moduleName}, usando config del site`);
      }

      // 3. Cargar configuraci√≥n din√°mica desde DB (si existe)
      const dynamicModuleConfig = await this.configManager.loadModuleConfig(
        this.siteId,
        instanceId
      );

      // 4. Merge de todas las configuraciones en orden de prioridad:
      //    base ‚Üí parent override ‚Üí site override ‚Üí DB config ‚Üí moduleConfig (runtime)
      const finalConfig = {
        ...(cascadeConfig || {}), // Config en cascada (ya viene merged)
        ...dynamicModuleConfig,    // Config de DB
        ...moduleConfig            // Config runtime (tiene m√°xima prioridad)
      };
      
      // Preservar metadata si existe
      if (cascadeConfig && cascadeConfig._meta) {
        finalConfig._meta = cascadeConfig._meta;
      }

      console.log(`[ModuleInitializer] Config final para ${instanceId}:`, {
        hasCascadeConfig: !!cascadeConfig,
        hasDynamicConfig: Object.keys(dynamicModuleConfig).length > 0,
        hasMetadata: !!finalConfig._meta
      });

      // 5. Cargar c√≥digo del m√≥dulo
      const ModuleClass = await this.loadModuleCode(moduleName, moduleConfig.version);

      // 6. Crear contexto para el m√≥dulo
      const context = this.createModuleContext(instanceId, finalConfig);

      // 7. Crear instancia del m√≥dulo
      const instance = new ModuleClass(finalConfig, context);

      // 8. Ejecutar hooks onBeforeInit
      await this.executeHooks(instanceId, 'onBeforeInit', { config: finalConfig, context });

      // 9. Llamar al m√©todo init del m√≥dulo si existe
      if (typeof instance.init === 'function') {
        await instance.init();
      }

      // 10. Llamar al m√©todo install del m√≥dulo para registrar rutas
      if (typeof instance.install === 'function') {
        const routingConfig = finalConfig.routing || {};
        const {
          parentModule: routingParent = parentModule,
          inheritLayouts = {},
          routePrefix = null
        } = routingConfig;
        
        console.log(`[ModuleInitializer] Registrando rutas de ${instanceId}...`);
        await instance.install(this.siteId, routingParent, inheritLayouts, routePrefix);
      }

      // 11. Ejecutar hooks onAfterInit
      await this.executeHooks(instanceId, 'onAfterInit', { instance, config: finalConfig, context });

      // Guardar m√≥dulo inicializado
      this.modules.set(instanceId, {
        config: finalConfig,
        instance,
        state: ModuleLifecycleState.INITIALIZED,
        error: null
      });

      console.log(`[ModuleInitializer] M√≥dulo ${instanceId} inicializado correctamente`);
      this.emit('module:initialized', { instanceId, instance });

    } catch (error) {
      this.setModuleState(instanceId, ModuleLifecycleState.ERROR);
      this.emit('module:error', { instanceId, error, phase: 'initialization' });
      throw error;
    }
  }

  /**
   * Monta una lista de m√≥dulos (los hace visibles/activos)
   */
  async mountModules(moduleIds) {
    for (const instanceId of moduleIds) {
      try {
        await this.mountModule(instanceId);
      } catch (error) {
        console.error(`[ModuleInitializer] Error montando ${instanceId}:`, error);
      }
    }
  }

  /**
   * Monta un m√≥dulo individual
   */
  async mountModule(instanceId) {
    const moduleData = this.modules.get(instanceId);
    if (!moduleData) {
      throw new Error(`M√≥dulo ${instanceId} no est√° inicializado`);
    }

    if (moduleData.state !== ModuleLifecycleState.INITIALIZED) {
      console.warn(`[ModuleInitializer] M√≥dulo ${instanceId} no est√° en estado INITIALIZED`);
      return;
    }

    console.log(`[ModuleInitializer] Montando m√≥dulo ${instanceId}...`);

    this.setModuleState(instanceId, ModuleLifecycleState.MOUNTING);
    this.emit('module:mounting', { instanceId });

    try {
      const { instance, config } = moduleData;

      // 1. Ejecutar hooks onBeforeMount
      await this.executeHooks(instanceId, 'onBeforeMount', { instance, config });

      // 2. Llamar al m√©todo mount del m√≥dulo si existe
      if (typeof instance.mount === 'function') {
        await instance.mount();
      }

      // 3. Ejecutar hooks onAfterMount
      await this.executeHooks(instanceId, 'onAfterMount', { instance, config });

      this.setModuleState(instanceId, ModuleLifecycleState.MOUNTED);
      this.emit('module:mounted', { instanceId });

      console.log(`[ModuleInitializer] M√≥dulo ${instanceId} montado correctamente`);

    } catch (error) {
      this.setModuleState(instanceId, ModuleLifecycleState.ERROR);
      this.emit('module:error', { instanceId, error, phase: 'mounting' });
      throw error;
    }
  }

  /**
   * Desmonta un m√≥dulo (lo oculta/desactiva pero puede volver a montarse)
   */
  async unmountModule(instanceId) {
    const moduleData = this.modules.get(instanceId);
    if (!moduleData || moduleData.state !== ModuleLifecycleState.MOUNTED) {
      console.warn(`[ModuleInitializer] M√≥dulo ${instanceId} no est√° montado`);
      return;
    }

    console.log(`[ModuleInitializer] Desmontando m√≥dulo ${instanceId}...`);

    this.setModuleState(instanceId, ModuleLifecycleState.UNMOUNTING);

    try {
      const { instance, config } = moduleData;

      // 1. Ejecutar hooks onBeforeUnmount
      await this.executeHooks(instanceId, 'onBeforeUnmount', { instance, config });

      // 2. Llamar al m√©todo unmount del m√≥dulo si existe
      if (typeof instance.unmount === 'function') {
        await instance.unmount();
      }

      // 3. Ejecutar hooks onAfterUnmount
      await this.executeHooks(instanceId, 'onAfterUnmount', { instance, config });

      this.setModuleState(instanceId, ModuleLifecycleState.UNMOUNTED);
      this.emit('module:unmounted', { instanceId });

      console.log(`[ModuleInitializer] M√≥dulo ${instanceId} desmontado correctamente`);

    } catch (error) {
      this.setModuleState(instanceId, ModuleLifecycleState.ERROR);
      this.emit('module:error', { instanceId, error, phase: 'unmounting' });
      throw error;
    }
  }

  /**
   * Destruye un m√≥dulo completamente (libera recursos)
   */
  async destroyModule(instanceId) {
    const moduleData = this.modules.get(instanceId);
    if (!moduleData) {
      console.warn(`[ModuleInitializer] M√≥dulo ${instanceId} no existe`);
      return;
    }

    console.log(`[ModuleInitializer] Destruyendo m√≥dulo ${instanceId}...`);

    this.setModuleState(instanceId, ModuleLifecycleState.DESTROYING);

    try {
      const { instance, config } = moduleData;

      // Si est√° montado, desmontarlo primero
      if (moduleData.state === ModuleLifecycleState.MOUNTED) {
        await this.unmountModule(instanceId);
      }

      // 1. Ejecutar hooks onBeforeDestroy
      await this.executeHooks(instanceId, 'onBeforeDestroy', { instance, config });

      // 2. Llamar al m√©todo destroy del m√≥dulo si existe
      if (typeof instance.destroy === 'function') {
        await instance.destroy();
      }

      // 3. Ejecutar hooks onAfterDestroy
      await this.executeHooks(instanceId, 'onAfterDestroy', { instance, config });

      // 4. Limpiar contexto y hooks
      this.contexts.delete(instanceId);
      this.hooks.delete(instanceId);

      this.setModuleState(instanceId, ModuleLifecycleState.DESTROYED);
      this.emit('module:destroyed', { instanceId });

      console.log(`[ModuleInitializer] M√≥dulo ${instanceId} destruido correctamente`);

    } catch (error) {
      this.setModuleState(instanceId, ModuleLifecycleState.ERROR);
      this.emit('module:error', { instanceId, error, phase: 'destroying' });
      throw error;
    }
  }

  /**
   * Configura lazy loading para m√≥dulos no cr√≠ticos
   */
  setupLazyLoading(lazyModuleIds) {
    console.log(`[ModuleInitializer] Configurando lazy loading para ${lazyModuleIds.length} m√≥dulos`);

    for (const instanceId of lazyModuleIds) {
      const moduleConfig = this.getModuleConfig(instanceId);
      
      // Registrar m√≥dulo lazy pero no cargarlo todav√≠a
      this.modules.set(instanceId, {
        config: moduleConfig,
        instance: null,
        state: ModuleLifecycleState.UNINITIALIZED,
        error: null
      });

      // Configurar trigger de carga seg√∫n configuraci√≥n
      this.setupLazyLoadTrigger(instanceId, moduleConfig);
    }
  }

  /**
   * Configura el trigger para cargar un m√≥dulo lazy
   */
  setupLazyLoadTrigger(instanceId, moduleConfig) {
    // Por defecto, carga bajo demanda cuando se accede al m√≥dulo
    // Puede configurarse para cargar en idle, viewport, interacci√≥n, etc.
    
    const trigger = moduleConfig.lazyTrigger || 'manual';

    switch (trigger) {
      case 'idle':
        // Cargar cuando el navegador est√© idle
        if (typeof requestIdleCallback !== 'undefined') {
          requestIdleCallback(() => this.loadLazyModule(instanceId));
        } else {
          setTimeout(() => this.loadLazyModule(instanceId), 2000);
        }
        break;

      case 'viewport':
        // Cargar cuando el elemento entre al viewport (requiere observer)
        // Implementaci√≥n espec√≠fica del m√≥dulo
        break;

      case 'interaction':
        // Cargar en la primera interacci√≥n del usuario
        const loadOnInteraction = () => {
          this.loadLazyModule(instanceId);
          document.removeEventListener('click', loadOnInteraction);
          document.removeEventListener('scroll', loadOnInteraction);
          document.removeEventListener('keydown', loadOnInteraction);
        };
        document.addEventListener('click', loadOnInteraction, { once: true });
        document.addEventListener('scroll', loadOnInteraction, { once: true });
        document.addEventListener('keydown', loadOnInteraction, { once: true });
        break;

      case 'manual':
      default:
        // No hacer nada, esperar a que se llame manualmente
        console.log(`[ModuleInitializer] M√≥dulo ${instanceId} configurado para carga manual`);
        break;
    }
  }

  /**
   * Carga un m√≥dulo lazy bajo demanda
   */
  async loadLazyModule(instanceId) {
    const moduleData = this.modules.get(instanceId);
    
    if (!moduleData) {
      throw new Error(`M√≥dulo lazy ${instanceId} no est√° registrado`);
    }

    if (moduleData.state !== ModuleLifecycleState.UNINITIALIZED) {
      console.warn(`[ModuleInitializer] M√≥dulo ${instanceId} ya est√° cargado o cargando`);
      return moduleData.instance;
    }

    console.log(`[ModuleInitializer] Cargando m√≥dulo lazy ${instanceId}...`);
    this.emit('module:lazy-loading', { instanceId });

    try {
      // Inicializar y montar el m√≥dulo
      await this.initializeModule(instanceId);
      await this.mountModule(instanceId);

      this.emit('module:lazy-loaded', { instanceId });
      
      return this.modules.get(instanceId).instance;

    } catch (error) {
      console.error(`[ModuleInitializer] Error cargando m√≥dulo lazy ${instanceId}:`, error);
      this.emit('module:lazy-error', { instanceId, error });
      throw error;
    }
  }

  /**
   * Carga el c√≥digo de un m√≥dulo din√°micamente
   */
  async loadModuleCode(moduleName, version) {
    const cacheKey = `${moduleName}@${version || 'latest'}`;

    // Verificar cache
    if (this.moduleCache.has(cacheKey)) {
      console.log(`[ModuleInitializer] M√≥dulo ${cacheKey} cargado desde cache`);
      return this.moduleCache.get(cacheKey);
    }

    console.log(`[ModuleInitializer] Cargando c√≥digo del m√≥dulo ${cacheKey}...`);

    try {
      // Construir ruta del m√≥dulo
      const modulePath = version 
        ? `/src/modules/${moduleName}/${version}/index.js`
        : `/src/modules/${moduleName}/index.js`;

      // Cargar m√≥dulo din√°micamente
      const module = await import(/* @vite-ignore */ modulePath);
      
      // El m√≥dulo debe exportar una clase default
      const ModuleClass = module.default;
      
      if (!ModuleClass) {
        throw new Error(`M√≥dulo ${moduleName} no exporta una clase default`);
      }

      // Guardar en cache
      this.moduleCache.set(cacheKey, ModuleClass);

      return ModuleClass;

    } catch (error) {
      console.error(`[ModuleInitializer] Error cargando m√≥dulo ${cacheKey}:`, error);
      throw new Error(`No se pudo cargar el m√≥dulo ${cacheKey}: ${error.message}`);
    }
  }

  /**
   * Crea el contexto compartido para un m√≥dulo
   */
  createModuleContext(instanceId, config) {
    const context = {
      // Identificaci√≥n
      siteId: this.siteId,
      instanceId: instanceId,
      moduleName: config.name,
      moduleVersion: config.version,

      // Servicios core
      sessionManager: this.sessionManager,
      configManager: this.configManager,
      moduleInitializer: this,

      // M√©todos para interactuar con otros m√≥dulos
      getModule: (targetInstanceId) => this.getModuleInstance(targetInstanceId),
      getModules: () => this.getAllModuleInstances(),
      
      // M√©todos para hooks
      registerHook: (hookName, callback) => this.registerHook(instanceId, hookName, callback),
      unregisterHook: (hookName, callback) => this.unregisterHook(instanceId, hookName, callback),
      
      // Eventos
      emit: (eventName, data) => this.emit(`module:${instanceId}:${eventName}`, data),
      on: (eventName, callback) => this.on(`module:${instanceId}:${eventName}`, callback),
      off: (eventName, callback) => this.off(`module:${instanceId}:${eventName}`, callback),

      // Almacenamiento compartido entre m√≥dulos
      shared: {}
    };

    this.contexts.set(instanceId, context);
    return context;
  }

  /**
   * Registra un hook para un m√≥dulo
   */
  registerHook(instanceId, hookName, callback) {
    if (!this.hooks.has(instanceId)) {
      this.hooks.set(instanceId, new Map());
    }

    const moduleHooks = this.hooks.get(instanceId);
    
    if (!moduleHooks.has(hookName)) {
      moduleHooks.set(hookName, []);
    }

    moduleHooks.get(hookName).push(callback);
    
    console.log(`[ModuleInitializer] Hook ${hookName} registrado para ${instanceId}`);
  }

  /**
   * Desregistra un hook
   */
  unregisterHook(instanceId, hookName, callback) {
    const moduleHooks = this.hooks.get(instanceId);
    if (!moduleHooks) return;

    const callbacks = moduleHooks.get(hookName);
    if (!callbacks) return;

    const index = callbacks.indexOf(callback);
    if (index > -1) {
      callbacks.splice(index, 1);
      console.log(`[ModuleInitializer] Hook ${hookName} desregistrado de ${instanceId}`);
    }
  }

  /**
   * Ejecuta todos los hooks registrados para un evento
   */
  async executeHooks(instanceId, hookName, data) {
    // 1. Ejecutar hooks del m√≥dulo espec√≠fico
    const moduleHooks = this.hooks.get(instanceId);
    if (moduleHooks && moduleHooks.has(hookName)) {
      const callbacks = moduleHooks.get(hookName);
      for (const callback of callbacks) {
        try {
          await callback(data);
        } catch (error) {
          console.error(`[ModuleInitializer] Error en hook ${hookName} de ${instanceId}:`, error);
        }
      }
    }

    // 2. Ejecutar hooks definidos en la configuraci√≥n del m√≥dulo
    const config = this.getModuleConfig(instanceId);
    if (config && config.hooks && typeof config.hooks[hookName] === 'function') {
      try {
        await config.hooks[hookName](data);
      } catch (error) {
        console.error(`[ModuleInitializer] Error en hook config ${hookName} de ${instanceId}:`, error);
      }
    }
  }

  /**
   * Obtiene la configuraci√≥n de un m√≥dulo
   */
  getModuleConfig(instanceId) {
    return this.siteConfig.modules.find(m => m.instanceId === instanceId);
  }

  /**
   * Obtiene el m√≥dulo padre de un m√≥dulo dado
   * Busca en la jerarqu√≠a definida en la configuraci√≥n
   */
  getParentModule(instanceId) {
    const moduleConfig = this.getModuleConfig(instanceId);
    if (!moduleConfig) return null;
    
    // 1. Si el m√≥dulo tiene expl√≠citamente definido su parent en routing
    if (moduleConfig.routing && moduleConfig.routing.parentModule) {
      return moduleConfig.routing.parentModule;
    }
    
    // 2. Buscar en la jerarqu√≠a inversa: ¬øqui√©n define este m√≥dulo en sus submodules?
    // Por ejemplo, si 'admin' define 'googleAds' en su modules array, entonces admin es el padre
    for (const potentialParent of this.siteConfig.modules) {
      const parentInstanceId = potentialParent.instanceId;
      const parentName = potentialParent.module || potentialParent.name;
      
      // Verificar si este potencial padre tiene un array de modules/submodules
      if (potentialParent.modules && Array.isArray(potentialParent.modules)) {
        const moduleName = moduleConfig.module || moduleConfig.name || instanceId;
        if (potentialParent.modules.includes(moduleName)) {
          console.log(`[ModuleInitializer] Padre encontrado: ${parentName} ‚Üí ${moduleName}`);
          return parentName;
        }
      }
    }
    
    // 3. Si no se encuentra padre, es un m√≥dulo ra√≠z
    return null;
  }

  /**
   * Obtiene la instancia de un m√≥dulo
   */
  getModuleInstance(instanceId) {
    const moduleData = this.modules.get(instanceId);
    return moduleData ? moduleData.instance : null;
  }

  /**
   * Obtiene todas las instancias de m√≥dulos montados
   */
  getAllModuleInstances() {
    const instances = {};
    for (const [instanceId, moduleData] of this.modules) {
      if (moduleData.state === ModuleLifecycleState.MOUNTED) {
        instances[instanceId] = moduleData.instance;
      }
    }
    return instances;
  }

  /**
   * Obtiene el estado de un m√≥dulo
   */
  getModuleState(instanceId) {
    const moduleData = this.modules.get(instanceId);
    return moduleData ? moduleData.state : ModuleLifecycleState.UNINITIALIZED;
  }

  /**
   * Establece el estado de un m√≥dulo
   */
  setModuleState(instanceId, state) {
    const moduleData = this.modules.get(instanceId);
    if (moduleData) {
      moduleData.state = state;
      this.emit('module:state-changed', { instanceId, state });
    }
  }

  /**
   * Obtiene informaci√≥n de diagn√≥stico del sistema
   */
  getDiagnostics() {
    const diagnostics = {
      siteId: this.siteId,
      initialized: this.initialized,
      totalModules: this.modules.size,
      states: {},
      errors: []
    };

    // Contar m√≥dulos por estado
    for (const [instanceId, moduleData] of this.modules) {
      const state = moduleData.state;
      diagnostics.states[state] = (diagnostics.states[state] || 0) + 1;

      if (state === ModuleLifecycleState.ERROR) {
        diagnostics.errors.push({
          instanceId,
          error: moduleData.error?.message || 'Unknown error'
        });
      }
    }

    return diagnostics;
  }

  /**
   * Reinicia un m√≥dulo (destroy + init + mount)
   */
  async restartModule(instanceId) {
    console.log(`[ModuleInitializer] Reiniciando m√≥dulo ${instanceId}...`);
    
    await this.destroyModule(instanceId);
    await this.initializeModule(instanceId);
    await this.mountModule(instanceId);
    
    console.log(`[ModuleInitializer] M√≥dulo ${instanceId} reiniciado correctamente`);
  }

  /**
   * Destruye todos los m√≥dulos y limpia recursos
   */
  async destroy() {
    console.log(`[ModuleInitializer] Destruyendo site ${this.siteId}...`);

    const moduleIds = Array.from(this.modules.keys());
    
    for (const instanceId of moduleIds) {
      try {
        await this.destroyModule(instanceId);
      } catch (error) {
        console.error(`[ModuleInitializer] Error destruyendo ${instanceId}:`, error);
      }
    }

    this.modules.clear();
    this.hooks.clear();
    this.contexts.clear();
    this.listeners.clear();
    this.moduleCache.clear();

    this.initialized = false;

    console.log(`[ModuleInitializer] Site ${this.siteId} destruido correctamente`);
  }

  /**
   * Sistema de eventos
   */
  on(eventName, callback) {
    if (!this.listeners.has(eventName)) {
      this.listeners.set(eventName, []);
    }
    this.listeners.get(eventName).push(callback);
  }

  off(eventName, callback) {
    const callbacks = this.listeners.get(eventName);
    if (!callbacks) return;

    const index = callbacks.indexOf(callback);
    if (index > -1) {
      callbacks.splice(index, 1);
    }
  }

  emit(eventName, data) {
    const callbacks = this.listeners.get(eventName);
    if (!callbacks) return;

    for (const callback of callbacks) {
      try {
        callback(data);
      } catch (error) {
        console.error(`[ModuleInitializer] Error en listener de ${eventName}:`, error);
      }
    }
  }
}

export default ModuleInitializer;
